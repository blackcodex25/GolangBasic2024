package main

import (
	f "fmt"
)

// อินเตอร์เฟซ I ประกาศเมธอด M() ซึ่งไม่มีพารามิเตอร์และไม่มีค่าที่คืนกลับ
type I interface {
	M()
}

// ประกาศ struct ชื่อตัวแปร T กำหนดฟิลด์ S ชนิด string
type T struct {
	S string
}

// เรียกใช้เมธอด M() ถูกประกาศสำหรับ pointer ไปยัง T (*T)
func (t *T) M() {
	// ในเมธอด M() มีการตรวจสอบว่าตัวรับ t มีค่าเป็น nil หรือไม่
	if t == nil {
		// ถ้าใช่ จะพิมพ์ <nil>
		f.Println("<nil>")
		return // หยุดการทำงานของเมธอดด้วยการ return
		/*
				เพื่อไม่ให้โปรแกรมพยายามเข้าถึงฟิลด์ S ของ t
			ซึ่งทำให้เกิดข้อผิดพลาด (nil pointer dereference)
		*/

	}
	// ถ้าไม่ใช่ พิมพ์ค่าของฟิลด์ S ชนิดข้อมูลของ struct T
	f.Println(t.S) // กำหนดพอยน์เตอร์ตัวรับ t.S เรียกใช้ฟิลด์ S ของ Struct T

}

func main() {
	var i I // ประกาศตัวแปร i ที่เป็นชนิดอินเตอร์เฟซ I
	// ประกาศตัวแปร t ที่เป็น pointer ไปยัง T และกำหนดค่าให้เป็น nil
	var t *T
	i = t       // กำหนดค่า t ให้กับ i (i = t)
	describe(i) // เรียกใช้ฟังก์ชัน describer(i) เพื่อพิมพ์รายละเอียดของ i
	i.M()       // เรียกใช้เมธอด M() ของ i
	// ประกาศตัวแปร t ชี้ไปยัง struct T ที่มีฟิลด์ S เป็น "hello"
	i = &T{"hello"} // กำหนด pointer ไปยัง T ให้กับ i (i = &T{"hello"})
	describe(i)     // เรียกใช้ฟังก์ชัน describe(i) เพื่อพิมพ์รายละเอียดของ i
	i.M()           // เรียกใช้เมธอด M() ของ i

}

// ฟังก์ชัน describe() ใช้ฟังก์ชัน Printf() เพื่อพิมพ์ค่าของตัวแปร i และชนิดข้อมูลของ i
func describe(i I) {
	f.Printf("(%v, %T)\n", i, i)
} /* Note: %v แทนค่าของตัวแปร
%T แทนชนิดข้อมูลของตัวแปร */

/* Values
ถ้าค่าที่เป็นรูปธรรมภายในอินเตอร์เฟซเป็น nil เมธอดจะถูกเรียกใช้ด้วยตัวรับที่เป็น nil (nil receiver)
ในบางภาษาสิ่งนี้จะทำให้เกิดข้อยกเว้น null pointer แต่ในภาษา Go มักจะเขียนเมธอด
ที่จัดการกับการถูกเรียกใช้ด้วยตัวรับที่เป็น nil (nil receiver) ได้อย่างดี
เช่นกับเมธอด M ในตัวอย่างนี้
อินเทอร์เฟซที่ถือค่า nil ที่เป็นรูปธรรมจะไม่เป็น nil เอง
*/

/* หลักการทำงานของโปรแกรม
โปรแกรมนี้มีการประกาศและใช้งานอินเตอร์เฟซ I ที่มีเมธอด M() จากนั้นใช้ struct ชื่อ T
เพื่อ implement เมธอด M() ในลักษณะต่างๆ รวมถึงการจัดการกับค่าที่เป็น nil
โครงสร้างของโปรแกรม
1.การนำเข้าแพ็กเกจ
2.การประกาศอินเตอร์เฟซ I
3.การประกาศ struct ชื่อตัวแปร T และการ implement อินเตอร์เฟซ I
4.ฟังก์ชันหลัก
5.ฟังก์ชัน describer

import("fmt")
นำเข้าแพ็กเกจ fmt เพื่อใช้สำหรับการพิมพ์ข้อความ

type I interface{
	M()
}
อินเตอร์เฟซ I ประกาศเมธอด M() ซึ่งไม่มีพารามิเตอร์และไม่มีค่าที่คืนกลับ

type T struct{
	S string
}
T เป็น struct ที่มีฟิลด์ S ชนิด string

func (t *T) M() {
if == nil {
	fmt.Println("<nil>")
	return
	}
	fmt.Println(t.S)
}
เมธอด M() ถูกประกาศสำหรับ pointer ไปยัง T (*T)
ในเมธอด M() มีการตรวจสอบว่าตัวรับ t มีค่าเป็น nil หรือไม่
ถ้าใช่ จะพิมพ์ <nil> และ return ทันที
ถ้าไม่ใช่ จะพิมพ์ค่าของฟิลด์ S

func main(){
	var i I
	var t *T

	i = t
	describe(i)
	i.M()

	i = &T{"hello"}
	describe(i)
	i.M()
}
ประกาศตัวแปร i ที่เป็นชนิดอินเตอร์เฟซ I
ประกาศตัวแปร t ที่เป็น pointer ไปยัง T และกำหนดค่าให้เป็น nil
	กำหนดค่า t ให้กับ i (i = t)
	เรียกใช้ฟังก์ชัน describe(i) เพื่อพิมพ์รายละเอียดของ i
	เรียกใช้เมธอด M() ของ i

สร้างตัวแปร t ที่ชี้ไปยัง T ที่มีฟิลด์ S เป็น "hello"
	กำหนด pointer ไปยัง T ให้กับ i (i = &T{"hello"})
	เรียกใช้ฟังก์ชัน describe(i) เพื่อพิมพ์รายละเอียดของ i
	เรียกใช้เมธอด M() ของ i

func describe(i I){
	fmt.Printf("(%v, %T)\n", i, i)
}
ฟังก์ชัน describe ใช้ fmt.Printf() เพื่อพิมพ์ค่าของตัวแปร
	i  และชนิดข้อมูลของ i
	%v แทนค่าของตัวแปร
	%T แทนชนิดข้อมูลของตัวแปร
*/

/* การทำงานของโปรแกรม
		1.การจัดการค่า nil
var t *T
i = t
describe(i)
i.M()
t เป็น pointer ไปยัง T และมีค่าเป็น nil
i ถูกกำหนดให้เป็น t (ซึ่งเป็น nil)
ฟังก์ชัน describe(i) พิมพ์ค่า (nil, *main.T) ซึ่ง
หมายความว่า i เป็น pointer ไปยัง T ที่เป็น nil
เมธอด M() พิมพ์ <nil> เนื่องจาก t เป็น nil

		2.การใช้งาน Pointer ไปยัง T ที่มีค่า "hello"
i = &T{"hello"}
decribe(i)
i.M()
i ถูกกำหนดให้เป็น pointer ไปยัง T ที่มีฟิลด์ S เป็น "hello"
ฟังก์ชัน describe(i) พิมพ์ค่า (&{hello}, *main.T)
ซึ่งหมายความว่า i เป็น pointer ไปยัง T ที่มีค่า S เป็น "hello"
เมธอด M() พิมพ์ค่า "hello"
*/

/* สรุป
โปรแกรมนี้แสดงการใช้งานอินเตอร์เฟซ I ที่มีเมธอด M()
โดยมีการ implement เมธอด M() สำหรับ pointer ไปยัง struct T (*T)
เมธอด M() จัดการกับค่าที่เป็น nil โดยตรวจสอบค่า nil ก่อนเรียกใช้ค่าของฟิลด์ใน
struct ซึ่งช่วยให้การทำงานของโปรแกรมปลอดภัยจากข้อผิดพลาดที่อาจเกิดจากการเข้าถึง
ค่า nil นอกจากนี้ยังแสดงให้เห็นการกำหนดค่าและการใช้งานอินเตอร์เฟซใน Go
*/
