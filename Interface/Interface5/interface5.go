package main

import (
	f "fmt"
)

/* ค่าอินเทอร์เฟซที่เป็น nil
จะไม่มีทั้งค่าและประเภทที่เป็นรูปธรรม
การเรียกเมธอดบนอินเทอร์เฟซที่เป็น nil
จะทำให้เกิดข้อผิดพลาดใน ขณะรันไทม์
เนื่องจากไม่มีประเภทภายในอินเทอร์เฟซที่จะ
ระบุได้ว่าควรเรียกเมธอดที่เป็นรูปธรรมใด
*/
/* ตัวอย่างการใช้งานอินเตอร์เฟซ(interface) ในภาษา Go
โดยแสดงให้เห็นการใช้งานอินเตอร์เฟซที่ยังไม่ได้กำหนดค่า
(nil interface) และการเรียกใช้เมธอดในสถานการณ์นี้
*/
// ประกาศอินเตอร์เฟซชื่อ I ประกาศเมธอด M() ซึ่งไม่มีพารามิเตอร์และไม่มีค่าที่คืนกลับ
type I interface {
	M()
}

// ประกาศฟังก์ชันชื่อ describe()
// กำหนดพารามิเตอร์ตัวรับชื่อ i ชนิดอินเตอร์เฟซของ I
func describe(i I) {
	// ประกาศฟังก์ชัน Printf() ไม่ขึ้นบรรทัดใหม่ ใช้สำหรับแสดงผลค่าและชนิดของตัวแปร
	f.Printf("(%v,%T)\n", i, i) // พิิมพ์ค่าของ i และชนิดข้อมูลของ I
	// พิมพ์ผลลัพธ์ออกจอ
}
func main() {
	// ประกาศตัวแปร i ชนิดข้อมูลอินเตอร์เฟซของ I
	var i I
	// ประกาศฟังก์ชันชื่อ describe() กำหนดค่าเป็น i พิมพ์รายละเอียดชนิดข้อมูลอินเตอร์เฟซของ I
	describe(i)
	// เรียกใช้เมธอด M() ผ่านตัวแปร i ที่มีชนิดข้อมูลอินเตอร์เฟซของ I
	i.M()
	/* (nil, <nil>)
	panic: runtime error: invalid memory address or nil pointer dereference */
}

/* สรุป
โปรแกรมนี้แสดงการประกาศอินเตอร์เฟซ I
และการใช้งานอินเตอร์เฟซที่ยังไม่ได้กำหนดค่า (nil interface)
การพิมพ์รายละเอียดของ อินเตอร์เฟซ I ด้วยฟังก์ชัน describe
แสดงให้เห็นว่าค่าและชนิดข้อมูลของอินเตอร์เฟซ i เป็น nil
การยายามเรียกใช้ เมธอด M() บนอินเตอร์เฟซ I ที่มีค่าเป็น nil
จะทำให้เกิด runtime panic เนื่องจากไม่มีค่าและชนิดข้อมูลที่
กำหนดเมธอด M() ไว้ การจัดการกับกรณี nil จึงเป็นสิ่งสำคัญ
ใการพัฒนาโปรแกรมที่ใช้งานอินเตอร์เฟซ
*/
/* วิธีแก้ panic: runtime error: invalid memory address or nil pointer dereference
สองวิธีคือ
1.ประกาศฟังก์ชัน struct และชนิดข้อมูลใหม่ type F float64
ตัวอย่าง
type T struct {
	S string
}

func (t *T) M(){
	f.Println(t.S)
}

2.ฟังก์ชันหลัก main
ประกาศตัวแปรและกำหนดชนิดข้อมูลของ struct
เรียกใช้ตัวแปรและกำหนดค่าให้ struct
เรียกใช้ฟังก์ชัน describe กำหนดค่า i พิมพ์รายละเอียดอินเตอร์เฟซของ I
เรียกใช้เมธอด M() เพื่อพิมพ์ผลลัพธ์ i
ตัวอย่างในฟังก์ชัน main
var i I

i = T{"hello"}
describe(i)
i.M()

i = F(math.Pi)
describe(i)
i.M()
*/
