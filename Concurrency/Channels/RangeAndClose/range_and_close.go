package main

import (
	f "fmt"
)

/*
	ประกาศฟังก์ชัน fibonacci รับพารามิเตอร์สองตัว:

n เป็น int และ c เป็น channels ชนิด int
*/
func fibonacci(n int, c chan int) {
	/* ประกาศตัวแปรสองตัว x และ y
	กำหนดค่า 0 และ 1 ตามลำดับ */
	x, y := 0, 1
	// ในลูป for ฟังก์ชันจะสร้างค่าลำดับ fibonacci
	// และส่งค่าเหล่านั้นไปยัง Channels พารามิเตอร์ c
	/* หลังจากส่งค่าทั้งหมด ฟังก์ชัน Close()
	จะปิด Channels ตัวแปร c เพื่อบอกว่า
	ไม่มีค่าที่จะส่งเพิ่มเติม */
	/* ประกาศตัวแปร i กำหนดค่า 0 ตรวสอบเงื่อนไข i น้อยกว่า n หรือไม่
	เพิ่มค่า i++ ทุกครั้งหลังจบลูป */
	for i := 0; i < n; i++ {
		// ถ้าใช่ เรียกใช้ตัวแปร x ส่งค่าไปยัง channels ตัวแปร c
		c <- x
		// การสลับค่าตัวแปร x และ y และคำนวณค่า Fibonacci
		// ค่าของ x จะถูกแทนที่ด้วยค่าปัจจุบันของ y
		// ค่าของ y จะถูกแทนที่ด้วยผลรวมของ x และ y ก่อนการสลับค่า
		x, y = y, x+y // บรรทัดนี้เป็นการคำนวณค่า Fibonacci
	}
	/* ถ้าไม่ใช่ ฟังก์ชัน Close จะปิด Channels ตัวแปร c
	เพื่อบอกว่าไม่มีค่าที่จะส่งเพิ่มเติม */
	close(c)
}
func main() {
	/* สร้าง Channels ของตัวแปร c
	กำหนดขนาดบัฟเฟอร์ 10 ซึ่งสามารถเก็บค่า int
	ได้สูงสุด 10 ค่าในเวลาเดียวกัน */
	c := make(chan int, 10)

	/* เรียกใช้ฟังก์ชัน fibonacci ใน Goroutine
	โดยส่งความจุของช่องสื่อสาร (cap(c), ซึ่งคือ 10)
	และ Channels ตัวแปร c เป็นพารามิเตอร์
	*/
	go fibonacci(cap(c), c)

	/* ใช้ลูป for เพื่ออ่านค่าจาก Channels ตัวแปร c
	 */
	/*ประกาศตัวแปร i และใช้ keyword range เพื่อเข้าถึงค่า
	Channels ตัวแปร c
	*/
	for i := range c {
		// พิมพ์ค่า i ที่มีชนิดข้อมูลของ Channels c ออกจอ
		f.Println(i)
	} /*เมื่อ channels ของตัวแปร c ถูกปิด
	(โดย close(c) ในฟังก์ชัน fibonacci)
	ลูป for จะหยุดทำงาน
	*/
} /* ผลลัพธ์
0, 1, 1, 2, 3, 5, 8, 13, 21, 34
ซึ่งเป็น 10 ลำดับค่า fibonacci แรก
*/

/* สรุป
โค้ดนี้แสดงการใช้งาน Goroutine และ Channel เพื่อสร้างและ
ส่งค่าลำดับ fibonacci ในภาษา Go ฟังก์ชัน fibonacci ถูก
เรียกใช้ใน Goroutine และส่งค่าลำดับ fibonacci
ไปยัง buffered channels เมื่อค่าทั้งหมดถูกส่งแล้ว channels
จะถูกปิดด้วยฟังก์ชัน Close() และในฟังก์ชัน main ที่ใช้ Goroutine
จะอ่านค่าจาก Channels และพิมพ์ผลลัพธ์ออกทางจอ การใช้ channel
ทำให้การสื่อสารและการซิงโครไนซ์ระหว่าง Goroutines เป็น
เรื่องง่ายและมีประสิทธิภาพ
*/
